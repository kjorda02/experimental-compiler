package experimental_compiler;
import java_cup.runtime.ComplexSymbolFactory.*;
import java_cup.runtime.*;
import java.util.HashMap;
import arbol.*;
import arbol.ref.*;
import arbol.val.*;
import arbol.type.*;
import arbol.flow.*;
import arbol.fun.*;
import datos.*;

parser code {:
    @Override
    public void unrecovered_syntax_error(Symbol cur_token) throws Exception {
        Main.report_error("Error sintàctic catastròfic", cur_token);
        done_parsing();        
    }

    @Override
    public void syntax_error(Symbol cur_token) {
        Main.report_error("Unexpected token", cur_token);
    }

    @Override
    public void report_fatal_error(String message, Object info) throws Exception {
        Main.report_error("Error catastròfic ("+message+")", info);
        done_parsing();
    }
:}

/* ===== Terminals (tokens from lexer) ===== */
terminal LKEY, RKEY;
terminal terminal_node GLOBAL, STRUCT, CONST, TYPE, IF, ELSE, WHILE, FOR, SWITCH, CASE, BREAK;
terminal terminal_node PLUS, NEG, MULT, DIV, LPAREN, RPAREN, SEMI, ASS, EXIT;
terminal AND, OR, NOT;
terminal LT, GT, LEQ, GEQ, EQ, NEQ;
terminal LBRAC, RBRAC;
terminal COMMA, DOT;
terminal terminal_node<basicType> INT, BOOL, STRING;
terminal terminal_node<Integer> INTLIT;
terminal terminal_node<Boolean> BOOLLIT;
terminal terminal_node<String> ID;

/* ========= Non-terminals ========= */
non terminal prog;
non terminal while_node while;
non terminal ifstmt_node ifstmt;
non terminal stmt_node blockstmt;
non terminal stmts_node stmts;
non terminal stmt_node stmt;
non terminal assign_node assign;

non terminal literal_expr_node literal;
non terminal expr_node atom_expr;
non terminal unaryOp_node unary_expr;
non terminal binaryOp_node binary_expr;
non terminal expr_node expr;

non terminal ref_node ref;

non terminal complexType type;
non terminal typedecl_node typedecl;
non terminal complexType.struct struct;
non terminal complexType.struct fields;

non terminal decl_node decl;

non terminal arglist_node arglist;
non terminal complexType.funcsig funcsig;
non terminal fundecl_node fundecl;

/* ========== Precedences ========== */
precedence left OR;
precedence left AND;
precedence left NOT;

precedence left EQ, NEQ;

precedence left LT, GT, LEQ, GEQ;

precedence left PLUS, NEG;
precedence left MULT;
precedence left DIV;

start with prog;

/* ========== Grammar rules ========== */

fields  ::= type:t ID:i SEMI
            {: RESULT = new complexType.struct(null, i.value, t); :}
        | type:t ID:i SEMI fields:f
            {: RESULT = f.addField(i.value, t); :}

        | error
        | error fields
        ;

struct  ::= STRUCT LKEY fields:f RKEY
            {: RESULT = f; :}
            
            | struct LKEY error RKEY
        ;

type    ::= INT:t
            {: RESULT = new complexType.primitive(null, t.value); :}
        | BOOL:t
            {: RESULT = new complexType.primitive(null, t.value); :}
        | STRING
        | LBRAC expr:e RBRAC type:t
            {: RESULT = new complexType.array(null, t, e); :}
        | MULT type:t
            {: RESULT = new complexType.pointer(null, t); :}
        | struct:s
            {: RESULT = s; :}

        | LBRAC error RBRAC type
        ;

typedecl    ::= TYPE ID type:t
        ;

decl    ::= type:t ID:i
            {: RESULT = new decl_node(t, i); :}
        | type:t ID:i ASS expr:e
            {: RESULT = new decl_node(t, i, e); :}
        | CONST:c type:t ID:i ASS expr:e
            {: RESULT = new decl_node(c.left, t, i, e); :}
        ;

arglist   ::= type:t ID:i COMMA arglist:l
            {: RESULT = new arglist_node(t, i, l); :}
        |
            {: RESULT = new arglist_node(); :} 
            
        ;

ref ::= ID:i
            {: RESULT = new identifier_ref_node(i); :}
        | ref:r LBRAC expr:e RBRAC
            {: RESULT = new displ_node(r, e); :}
        | ref:r DOT ID:i
            {: RESULT = new field_node(r, i); :}
        | ID:i LPAREN arglist:l RPAREN:rp
            {: RESULT = new call_node(i, l, rp.right); :}

        | ref:r LBRAC error RBRAC
        | ref:r DOT error
        ;

literal ::= INTLIT:i
            {: RESULT = new literal_expr_node(i); :}
        | BOOLLIT:b
            {: RESULT = new literal_expr_node(b); :}
        ;

atom_expr   ::= literal:e
            {: RESULT = new expr_node(e); :}
        | LPAREN expr:e RPAREN
            {: RESULT = e; :}
        | ref:r
            {: RESULT = new expr_node(r); :}

        | LPAREN error RPAREN
       ;

unary_expr  ::= atom_expr:e
            {: RESULT = new unaryOp_node(e); :}
        | NOT atom_expr:e
            {: RESULT = new unaryOp_node(OP.NOT, e); :}
        | NEG atom_expr:e
            {: RESULT = new unaryOp_node(OP.NEG, e); :}
        ;

binary_expr ::= unary_expr:e
            {: RESULT = new binaryOp_node(e); :}

        | binary_expr:e1 DIV binary_expr:e2
            {: RESULT = new binaryOp_node(OP.DIV, e1, e2); :}

        | binary_expr:e1 MULT binary_expr:e2
            {: RESULT = new binaryOp_node(OP.TIMES, e1, e2); :}
       
        | binary_expr:e1 PLUS binary_expr:e2
            {: RESULT = new binaryOp_node(OP.PLUS, e1, e2); :}

        | binary_expr:e1 NEG binary_expr:e2
            {: RESULT = new binaryOp_node(OP.NEG, e1, e2); :}

        | binary_expr:e1 LT binary_expr:e2
            {: RESULT = new binaryOp_node(OP.LT, e1, e2); :}

        | binary_expr:e1 GT binary_expr:e2
            {: RESULT = new binaryOp_node(OP.GT, e1, e2); :}

        | binary_expr:e1 LEQ binary_expr:e2
            {: RESULT = new binaryOp_node(OP.LEQ, e1, e2); :}

        | binary_expr:e1 GEQ binary_expr:e2
            {: RESULT = new binaryOp_node(OP.GEQ, e1, e2); :}

        | binary_expr:e1 EQ binary_expr:e2
            {: RESULT = new binaryOp_node(OP.EQ, e1, e2); :}

        | binary_expr:e1 NEQ binary_expr:e2
            {: RESULT = new binaryOp_node(OP.NEQ, e1, e2); :}

        | binary_expr:e1 AND binary_expr:e2
            {: RESULT = new binaryOp_node(OP.AND, e1, e2); :}

        | binary_expr:e1 OR binary_expr:e2
            {: RESULT = new binaryOp_node(OP.OR, e1, e2); :}
        ;

assign  ::= ref:r ASS expr:e
            {: RESULT = new assign_node(r, e); :}
        ;

expr    ::= binary_expr:e 
            {: RESULT = new expr_node(e); :}
        | assign:e
            {: RESULT = new expr_node(e); :}
        ;

ifstmt  ::= IF LPAREN expr:e RPAREN LKEY stmts:s RKEY
            {: RESULT = new ifstmt_node(e, s); :}
        ;

while   ::= WHILE LPAREN expr:e RPAREN LKEY stmts:s RKEY
            {: RESULT = new while_node(e, s); :}
        ;

stmt    ::= decl:d
            {: RESULT = new stmt_node(d); :}
        | expr:e
            {: RESULT = new stmt_node(e); :}
        
        | error
            {: RESULT = new stmt_node(new node()); :}
        ;

blockstmt ::= ifstmt:i
            {: RESULT = new stmt_node(i); :}
        | while:w
            {: RESULT = new stmt_node(w); :}
        ;

stmts    ::= stmt:s SEMI
            {: RESULT = new stmts_node(s); :}
        | stmt:s SEMI stmts:ss
            {: RESULT = new stmts_node(s, ss); :}
        | blockstmt:b
            {: RESULT = new stmts_node(b); :}
        | blockstmt:b stmts:ss
            {: RESULT = new stmts_node(b, ss); :}
        ;

funcsig  ::= type:t ID:i LPAREN arglist:l RPAREN
            {: RESULT = new complexType.funcsig(t, i, l); :}
        ;

fundecl ::= funcsig:sig LKEY stmts:s RKEY
            {: RESULT = new fundecl_node(sig, s); :}
        ;

prog    ::= fundecl:d
            {: d.gest(); :}
        | fundecl:d prog:p
            {: d.gest(); RESULT = p; :}
        | typedecl:d SEMI
            {: d.gest(); :}
        | typedecl:d prog:p
            {: d.gest(); RESULT = p; :}
        | decl:d SEMI
            {: d.gest(); :}
        | decl:d SEMI prog:p
            {: d.gest(); :}
        ;
